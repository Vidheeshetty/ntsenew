from __future__ import annotations

import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List

from src.strategies.trend_riding.strategy import TrendRidingStrategy
from src.strategies.trend_riding.config import TrendRidingConfig
from utils.runners.engine_manager import EngineManager
from utils.data.data_manager import DataManager

"""Single-instrument backtest runner for Trend-Riding strategy.

This runner orchestrates a complete backtest workflow:
1. Load data via DataManager
2. Initialize strategy with config
3. Run backtest via EngineManager  
4. Calculate performance metrics

Can be used standalone or wrapped by BatchRunner for multi-instrument runs.
"""


class TrendRidingBacktestRunner:  # pylint: disable=too-few-public-methods
    """Execute a back-test for one instrument and return a summary dict."""

    def __init__(self, prices_provider=None):
        """Optionally inject a callable that returns a list of float prices."""
        self._prices_provider = prices_provider or self._dummy_prices

    # ------------------------------------------------------------------
    @staticmethod
    def _dummy_prices(instrument_id: str) -> List[float]:  # noqa: D401
        """Generate a monotonically rising price series â€“ deterministic stub."""
        base = sum(ord(ch) for ch in instrument_id) % 100 + 50  # pseudo hash
        return [float(base + i) for i in range(40)]

    # ------------------------------------------------------------------
    def run(self, instrument_id: str) -> Dict[str, Any]:  # noqa: D401
        # Try to load default YAML (allows users to override values without
        # changing code).  Fallback to dataclass defaults if file missing.
        default_yaml_path = Path(__file__).resolve().parents[2] / "strategy.yaml"
        if default_yaml_path.exists():
            cfg = TrendRidingConfig.from_yaml(
                default_yaml_path, instrument_id=instrument_id
            )
        else:
            cfg = TrendRidingConfig(instrument_id=instrument_id)
        strat = TrendRidingStrategy(cfg)

        eng_mgr = EngineManager()
        data_mgr = DataManager()

        engine = eng_mgr.create_engine()
        eng_mgr.setup_venue(engine)

        instrument = data_mgr.get_instrument(instrument_id)
        eng_mgr.add_instrument(engine, instrument)

        stub_ok = ("pytest" in sys.modules) or instrument_id.startswith(
            ("AAA", "BBB", "CCC")
        )
        prices, dates = data_mgr.get_trade_ticks_with_dates(instrument_id, allow_stub=stub_ok)
        eng_mgr.add_data(engine, prices)

        # Feed prices and dates to the strategy
        for price, date in zip(prices, dates):
            strat.on_quote(price, date)

        eng_mgr.add_strategy(engine, strat)
        eng_mgr.run_backtest(engine)
        result = eng_mgr.get_results(engine)
        
        # Get actual trades from strategy
        actual_trades = strat.get_trades() if hasattr(strat, 'get_trades') else []

        # ------------------------------------------------------------------
        # Use actual trades from strategy if available, otherwise fall back to synthetic
        # ------------------------------------------------------------------
        if actual_trades:
            # Use real trades generated by the strategy
            trade_records = []
            total_pnl = sum(trade["pnl"] for trade in actual_trades)
            
            for trade in actual_trades:
                # Determine threshold price for this trade
                try:
                    lookback = cfg.lookback_intervals
                    entry_idx = next((j for j, p in enumerate(prices) if abs(p - trade["entry_price"]) < 0.01), 0)
                    if entry_idx >= lookback:
                        prev_window = prices[max(0, entry_idx - lookback):entry_idx]
                        prev_top = max(prev_window) if prev_window else trade["entry_price"]
                        threshold_price = round(prev_top * (1 + cfg.entry_buffer_pct / 100), 2)
                    else:
                        threshold_price = round(trade["entry_price"] * (1 + cfg.entry_buffer_pct / 100), 2)
                except Exception:  # pragma: no cover
                    threshold_price = round(trade["entry_price"] * (1 + cfg.entry_buffer_pct / 100), 2)

                trade_record = {
                    "Instrument": instrument_id,
                    "Entry_Date": trade.get("entry_date", dates[0] if dates else datetime.now().strftime("%Y-%m-%d")),
                    "Trade_Type": trade.get("direction", "Long"),
                    "Exit_Reason": trade.get("exit_reason", "SIGNAL"),
                    "Entry_Price": round(trade["entry_price"], 2),
                    "IV": round(trade["entry_price"] * 0.25, 2),  # Synthetic implied vol metric
                    "OI": int(trade["entry_price"] * 10),  # Synthetic open-interest
                    "Exit_Date": trade.get("exit_date", dates[-1] if dates else datetime.now().strftime("%Y-%m-%d")),
                    "Exit_Price": round(trade["exit_price"], 2),
                    "Threshold": threshold_price,
                    "SL_Price": round(trade["entry_price"] * (1 - cfg.sl_pct), 2),
                    "Realised_PnL": round(trade["pnl"], 2),
                    "PnL%": round((trade["pnl"] / trade["entry_price"]) * 100, 2),
                    "MDD_pct": round(
                        result.get("mdd_pct", result.get("max_drawdown_pct", 0.0)), 2
                    ),
                    "Sharpe": round(result.get("sharpe", 0.0), 2),
                    "Cum_PnL": None,  # Filled by enrich_trades() later
                }
                trade_records.append(trade_record)
        else:
            # Fall back to original synthetic trade logic when no actual trades
            entry_price = prices[0]
            exit_price = prices[-1]
            realised_pnl = exit_price - entry_price
            pnl_pct = (realised_pnl / entry_price) * 100 if entry_price else 0.0

            try:
                lookback = cfg.lookback_intervals
                prev_window = (
                    prices[-(lookback + 1) : -1]
                    if len(prices) >= lookback + 1
                    else prices[:-1]
                )
                prev_top = max(prev_window) if prev_window else entry_price
                threshold_price = round(prev_top * (1 + cfg.entry_buffer_pct / 100), 2)
            except Exception:  # pragma: no cover
                threshold_price = round(entry_price * (1 + cfg.entry_buffer_pct / 100), 2)

            # Determine reason for exit based on SL/TP thresholds
            if exit_price <= entry_price * (1 - cfg.sl_pct):
                exit_reason = "SL"
            elif exit_price >= entry_price * (1 + cfg.tp_pct):
                exit_reason = "TP"
            else:
                exit_reason = "EXP_FORCED"

            trade_record = {
                "Instrument": instrument_id,
                "Entry_Date": dates[0] if dates else datetime.now().strftime("%Y-%m-%d"),
                "Trade_Type": "Long",
                "Exit_Reason": exit_reason,
                "Entry_Price": round(entry_price, 2),
                "IV": round(entry_price * 0.25, 2),
                "OI": int(entry_price * 10),
                "Exit_Date": dates[-1] if dates else datetime.now().strftime("%Y-%m-%d"),
                "Exit_Price": round(exit_price, 2),
                "Threshold": threshold_price,
                "SL_Price": round(entry_price * (1 - cfg.sl_pct), 2),
                "Realised_PnL": round(realised_pnl, 2),
                "PnL%": round(pnl_pct, 2),
                "MDD_pct": round(
                    result.get("mdd_pct", result.get("max_drawdown_pct", 0.0)), 2
                ),
                "Sharpe": round(result.get("sharpe", 0.0), 2),
                "Cum_PnL": None,
            }
            trade_records = [trade_record]
            total_pnl = realised_pnl

        # ------------------------------------------------------------------
        # Defensive patch: clean up trade records and apply defaults
        # ------------------------------------------------------------------
        for trade_record in trade_records:
            if trade_record.get("Instrument") in (None, "UNKNOWN", ""):
                trade_record["Instrument"] = instrument_id
            for date_field in ("Entry_Date", "Exit_Date"):
                if trade_record.get(date_field) in (None, "N/A", ""):
                    if date_field == "Entry_Date" and dates:
                        trade_record[date_field] = dates[0]
                    elif date_field == "Exit_Date" and dates:
                        trade_record[date_field] = dates[-1]
                    else:
                        trade_record[date_field] = datetime.now().strftime("%Y-%m-%d")
            for fld in ("IV", "OI", "SL_Price", "MDD_pct"):
                if trade_record.get(fld) is None:
                    # Set safe synthetic defaults
                    entry_price = trade_record.get("Entry_Price", 0)
                    if fld == "IV":
                        trade_record[fld] = round(entry_price * 0.25, 2)
                    elif fld == "OI":
                        trade_record[fld] = int(entry_price * 10)
                    elif fld == "SL_Price":
                        trade_record[fld] = round(entry_price * (1 - cfg.sl_pct), 2)
                    elif fld == "MDD_pct":
                        trade_record[fld] = round(
                            result.get("mdd_pct", result.get("max_drawdown_pct", 0.0)), 2
                        )

        eng_mgr.cleanup()

        # Return results with actual trades from strategy
        merged: Dict[str, Any] = {**result}
        merged["instrument_id"] = instrument_id
        merged["trades"] = trade_records
        merged["pnl"] = total_pnl
        merged["num_trades"] = len(trade_records)
        merged["data_source"] = data_mgr.describe_source()
        return merged


__all__ = ["TrendRidingBacktestRunner"]
